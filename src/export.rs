use anyhow::Result;
use rusqlite::Connection;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;
use chrono::Utc;

/// Sanitizes a string to be a valid part of a hostname.
fn sanitize(name: &str) -> String {
    name.replace(|c: char| !(c.is_ascii_alphanumeric() || c == '-'), "-")
        .to_ascii_lowercase()
}

pub fn to_hosts_file_from_db(db_path: &Path, output_path: &Path) -> Result<()> {
    let conn = Connection::open(db_path)?;
    let file = File::create(output_path)?;
    let mut writer = BufWriter::new(file);

    writeln!(
        writer,
        "# AWS Inventory Hosts File\n# Generated by aws-inventory-sdk on {}\n# Use with Wireshark (Preferences -> Name Resolution -> Hosts File)\n",
        Utc::now()
    )?;

    let mut stmt = conn.prepare(
        "SELECT r.name, r.resource_type, r.region, r.arn, r.details, i.ip_address
         FROM resources r
         JOIN ip_addresses i ON r.id = i.resource_id
         ORDER BY r.resource_type, r.name",
    )?;

    let mut rows = stmt.query([])?;
    let mut current_type = String::new();

    while let Some(row) = rows.next()? {
        let name: String = row.get(0)?;
        let resource_type: String = row.get(1)?;
        let region: String = row.get(2)?;
        let arn: String = row.get(3)?;
        let details_json: String = row.get(4)?;
        let ip: String = row.get(5)?;

        if resource_type != current_type {
            if !current_type.is_empty() {
                writeln!(writer, "")?;
            }
            writeln!(writer, "# --- {}s ---", resource_type)?;
            current_type = resource_type.clone();
        }

        let details: serde_json::Value = serde_json::from_str(&details_json)?;

        let hostname = match resource_type.as_str() {
            "ec2:instance" => format!("ec2.{}.{}.{}", sanitize(&name), sanitize(&arn), sanitize(&region)),
            "elbv2:loadbalancer" => {
                let lb_type = details.get("type").and_then(|v| v.as_str()).unwrap_or("unknown");
                let dns_name = details.get("dns_name").and_then(|v| v.as_str()).unwrap_or("no-dns");
                format!("lb.{}.{}.{} # {}", sanitize(&name), sanitize(lb_type), sanitize(&region), dns_name)
            }
            "eks:pod" => {
                let cluster = details.get("cluster").and_then(|v| v.as_str()).unwrap_or("unknown-cluster");
                let namespace = details.get("namespace").and_then(|v| v.as_str()).unwrap_or("unknown-ns");
                format!("pod.{}.{}.{}.{}", sanitize(&name), sanitize(namespace), sanitize(cluster), sanitize(&region))
            }
            _ => format!("unknown.{}.{}.{}", sanitize(&name), sanitize(&arn), sanitize(&region)),
        };

        writeln!(writer, "{}\t{}", ip, hostname)?;
        }

    writer.flush()?;
    Ok(())
}